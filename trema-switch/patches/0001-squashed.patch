diff --git a/trema-edge-master/src/lib/buffer.c b/trema-edge-master/src/lib/buffer.c
index fe019cc..3004a3b 100644
--- a/trema-edge-master/src/lib/buffer.c
+++ b/trema-edge-master/src/lib/buffer.c
@@ -301,6 +301,13 @@ void
 reset_buffer( buffer *buf ) {
   assert( buf != NULL );
 
+  if ( buf->user_data != NULL && buf->user_data_free_function != NULL ) {
+    ( *buf->user_data_free_function )( buf );
+    assert( buf->user_data == NULL );
+    assert( buf->user_data_free_function == NULL );
+  }
+  buf->user_data = NULL;
+
   pthread_mutex_lock( ( ( private_buffer * ) buf )->mutex );
 
   private_buffer *pbuf = ( private_buffer * ) buf;
diff --git a/trema-edge-master/src/lib/packet_info.c b/trema-edge-master/src/lib/packet_info.c
index 848eb84..54b8c3e 100644
--- a/trema-edge-master/src/lib/packet_info.c
+++ b/trema-edge-master/src/lib/packet_info.c
@@ -53,6 +53,31 @@ calloc_packet_info( buffer *buf ) {
 }
 
 
+void
+copy_packet_info( buffer *dst, const buffer *src ) {
+  die_if_NULL( src );
+  die_if_NULL( dst );
+  
+  if ( src->user_data == NULL ) {
+    return;
+  }
+  calloc_packet_info( dst );
+  memcpy( dst->user_data, src->user_data, sizeof( packet_info ) );
+
+  packet_info *info = ( packet_info* ) dst->user_data;
+  ssize_t offset = (dst->data - src->data);
+
+  if(info->l2_header      != NULL) info->l2_header      += offset;
+  if(info->l2_payload     != NULL) info->l2_payload     += offset;
+  if(info->l3_header      != NULL) info->l3_header      += offset;
+  if(info->l3_payload     != NULL) info->l3_payload     += offset;
+  if(info->l4_header      != NULL) info->l4_header      += offset;
+  if(info->l4_payload     != NULL) info->l4_payload     += offset;
+  if(info->l2_vlan_header != NULL) info->l2_vlan_header += offset;
+  if(info->l2_mpls_header != NULL) info->l2_mpls_header += offset;
+}
+
+
 packet_info
 get_packet_info( const buffer *frame ) {
   die_if_NULL( frame );
diff --git a/trema-edge-master/src/lib/packet_info.h b/trema-edge-master/src/lib/packet_info.h
index 7a66bc8..aa9dd5f 100644
--- a/trema-edge-master/src/lib/packet_info.h
+++ b/trema-edge-master/src/lib/packet_info.h
@@ -237,6 +237,7 @@ bool parse_packet( buffer *buf );
 
 void calloc_packet_info( buffer *frame );
 void free_packet_info( buffer *frame );
+void copy_packet_info( buffer *dst, const buffer *src );
 packet_info get_packet_info( const buffer *frame );
 
 bool packet_type_eth_dix( const buffer *frame );
diff --git a/trema-edge-master/src/switch/datapath/async_event_notifier.c b/trema-edge-master/src/switch/datapath/async_event_notifier.c
index 8484e9f..f354d3a 100644
--- a/trema-edge-master/src/switch/datapath/async_event_notifier.c
+++ b/trema-edge-master/src/switch/datapath/async_event_notifier.c
@@ -163,10 +163,8 @@ save_packet( const buffer *packet ) {
   uint32_t buffer_id = get_buffer_id();
   if ( buffer_id != UINT32_MAX ) {
     packet_in_buffers[ buffer_id ].packet = duplicate_buffer( packet );
-    if ( packet->user_data != NULL ) {
-      calloc_packet_info( packet_in_buffers[ buffer_id ].packet );
-      memcpy( packet_in_buffers[ buffer_id ].packet->user_data, packet->user_data, sizeof( packet_info ) );
-    }
+    // duplicate_buffer() copies user_data, which points to old packet addresses
+    copy_packet_info( packet_in_buffers[ buffer_id ].packet, packet );
     time_now( &packet_in_buffers[ buffer_id ].saved_at );
   }
 
diff --git a/trema-edge-master/src/switch/datapath/ether_device.c b/trema-edge-master/src/switch/datapath/ether_device.c
index 616032b..de6e4f1 100644
--- a/trema-edge-master/src/switch/datapath/ether_device.c
+++ b/trema-edge-master/src/switch/datapath/ether_device.c
@@ -342,8 +342,32 @@ receive_frame( int fd, void *user_data ) {
             get_packet_buffers_length( device->recv_queue ), max_queue_length );
       frame = device->recv_buffer; // Use recv_buffer as a trash.
     }
+    reset_buffer( frame );
     append_back_buffer( frame, device->mtu );
 
+#if WITH_PCAP
+    ssize_t length = 0;
+    struct pcap_pkthdr *header = NULL;
+    const u_char *packet = NULL;
+    int ret = pcap_next_ex( device->pcap, &header, &packet );
+    if ( ret == 1 ) {
+      length = header->caplen;
+      if ( length > frame->length ) {
+        append_back_buffer( frame, length - frame->length );
+      }
+      memcpy( frame->data, packet, length );
+    }
+    else {
+      if ( frame != device->recv_buffer ) {
+        mark_packet_buffer_as_used( device->recv_queue, frame );
+      }
+      if ( ret == -1 ) {
+        error( "Receive error ( device = %s, pcap_err = %s ).",
+             device->name, pcap_geterr( device->pcap ) );
+      }
+      break;
+    }
+#else // WITH_PCAP
     ssize_t length = recv( device->fd, frame->data, frame->length, MSG_DONTWAIT );
     assert( length != 0 );
     if ( length < 0 ) {
@@ -358,13 +382,11 @@ receive_frame( int fd, void *user_data ) {
              device->name, safe_strerror_r( errno, error_string, sizeof( error_string ) ), errno );
       break;
     }
+#endif
     if ( frame != device->recv_buffer ) {
       frame->length = ( size_t ) length;
       enqueue_packet_buffer( device->recv_queue, frame );
     }
-    else {
-      reset_buffer( frame );
-    }
     count++;
   }
 
@@ -390,6 +412,14 @@ flush_send_queue( int fd, void *user_data ) {
   int count = 0;
   buffer *buf = NULL;
   while ( ( buf = peek_packet_buffer( device->send_queue ) ) != NULL && count < 256 ) {
+#if WITH_PCAP
+    if( pcap_sendpacket( device->pcap, buf->data, buf->length ) < 0 ){
+      error( "Failed to send a message to ethernet device ( device = %s, pcap_err = %s ).",
+        device->name, pcap_geterr( device->pcap ) );
+      return;
+    }
+    ssize_t length = buf->length;
+#else
     ssize_t length = sendto( device->fd, buf->data, buf->length, MSG_DONTWAIT, ( struct sockaddr * ) &sll, sizeof( sll ) );
     if ( length < 0 ) {
       if ( ( errno == EINTR ) || ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) ) {
@@ -400,6 +430,7 @@ flush_send_queue( int fd, void *user_data ) {
              device->name, safe_strerror_r( errno, error_string, sizeof( error_string ) ), errno );
       return;
     }
+#endif
 
     if ( ( size_t ) length < buf->length ) {
       remove_front_buffer( buf, ( size_t ) length );
@@ -466,6 +497,15 @@ create_ether_device( const char *name, const size_t max_send_queue, const size_t
 
   close( nfd );
 
+#ifdef WITH_PCAP
+  char errbuf[ PCAP_ERRBUF_SIZE ];
+  pcap_t *handle = pcap_open_live( name, BUFSIZ, 1, 100, errbuf );
+  if( handle == NULL ){
+    error( "device %s open failed %s", name, errbuf );
+    return NULL;
+  }
+  int fd = pcap_get_selectable_fd( handle );
+#else // WITH_PCAP
   int fd = socket( PF_PACKET, SOCK_RAW, htons( ETH_P_ALL ) );
   if ( fd < 0 ) {
     char error_string[ ERROR_STRING_SIZE ];
@@ -495,11 +535,15 @@ create_ether_device( const char *name, const size_t max_send_queue, const size_t
       break;
     }
   }
+#endif // WITH_PCAP
 
   ether_device *device = xmalloc( sizeof( ether_device ) );
   memset( device, 0, sizeof( ether_device ) );
   strncpy( device->name, name, IFNAMSIZ );
   device->name[ IFNAMSIZ - 1 ] = '\0';
+#if WITH_PCAP
+  device->pcap = handle;
+#endif
   device->fd = fd;
   device->ifindex = ifindex;
   memcpy( device->hw_addr, ifr.ifr_hwaddr.sa_data, ETH_ADDRLEN );
@@ -530,6 +574,12 @@ void
 delete_ether_device( ether_device *device ) {
   assert( device != NULL );
 
+#if WITH_PCAP
+  if ( device->pcap != NULL ) {
+    pcap_close( device->pcap );
+    device->pcap = NULL;
+  }
+#endif
   if ( device->fd >= 0 ) {
     set_readable_safe( device->fd, false );
     if ( get_packet_buffers_length( device->send_queue ) > 0 ) {
@@ -654,7 +704,7 @@ send_frame( ether_device *device, buffer *frame ) {
 
   debug( "Enqueueing a frame to send queue ( frame = %p, device = %s, queue length = %d, fd = %d ).",
          frame, device->name, get_packet_buffers_length( device->send_queue ), device->fd );
-  
+
   buffer *copy = get_free_packet_buffer( device->send_queue );
   assert( copy != NULL );
   copy_buffer( copy, frame );
diff --git a/trema-edge-master/src/switch/datapath/ether_device.h b/trema-edge-master/src/switch/datapath/ether_device.h
index d97f309..ab1ab00 100644
--- a/trema-edge-master/src/switch/datapath/ether_device.h
+++ b/trema-edge-master/src/switch/datapath/ether_device.h
@@ -22,6 +22,9 @@
 
 #include <net/if.h>
 #include <stdint.h>
+#if WITH_PCAP
+#include <pcap.h>
+#endif
 #include "ofdp_common.h"
 #include "packet_buffer.h"
 
@@ -59,6 +62,9 @@ typedef struct {
     uint64_t rx_crc_err;
     uint64_t collisions;
   } stats;
+#if WITH_PCAP
+  pcap_t *pcap;
+#endif
   int fd;
   packet_buffers *send_queue;
   packet_buffers *recv_queue;
